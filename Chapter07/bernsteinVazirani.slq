// Bernstein-Vazirani algorithm
// - Returns s where f(x) = sÂ·x mod 2
//

def bernstein_vazirani[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!uint[n]{
  cand := 0:uint[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // âˆ‘áµ¥|vâŸ©

  if f(cand) {
    phase(Ï€);
  }

  // state ignoring normalization:
  //   âˆ‘áµ¥(-1)^f(v)  |vâŸ©
  // = âˆ‘áµ¥(-1)^(sÂ·v) |vâŸ©
  // = (|0âŸ©+(-1)^(sâ‚)|1âŸ©) âŠ— â‹¯ âŠ— (|0âŸ©+(-1)^(sâ‚™)|1âŸ©)

  for k in [0..n) { cand[k] := H(cand[k]); }

  s := measure(cand);
  return s;
}

// TEST

def f[n:!â„•](s:!uint[n])(x:uint[n])lifted:ğ”¹{
  y := scal(s, x)%2;
  return y==1;
}

def scal[n:!â„•](const x:uint[n], const y:uint[n])qfree:uint[n] { 
  // computes the scalar product xÂ·y
  count := 0:uint[n];
  for k in [0..n) { 
    count+=x[k] && y[k];
  }
  return count;
}

def main() {
  for i in [0..8) {
	  s := i coerce !uint[4];
	  sâ‚€ := bernstein_vazirani(f(s));
	  assert(s==sâ‚€);
  }
}



