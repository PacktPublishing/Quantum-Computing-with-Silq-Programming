// Superposition generation
// - Generates the (normalized) superposition |0‚ü© + ... + |N-1‚ü© on k qubits  
//  
// - Requires N < 2^k

def superposition[k:!‚Ñï](N:!‚Ñï, qs:ùîπ^k)mfree:ùîπ^k{ 
    // generates the (normalized) superposition |0‚ü© + ... + |N-1‚ü© on k qubits

    assert(N <= 2^k); 
    // ensures that the biggest state |N-1‚ü© requires less than k qubits to be written
   
    n := floor(log(N)/log(2)) coerce !‚Ñï;
    r := N - 2^n coerce !‚Ñï;
    // decomposition N = 2^n + r

    // rotate first qubit
    (head,)~tail := qs; 
    Œ∏ := 2*asin(sqrt(r)/sqrt(N));
    // sin(Œ∏/2) = sqrt(r/N), cos(Œ∏/2) = sqrt((N-r)/N) = sqrt(2^n/N)
	
    head := rotY(Œ∏, head); 
    // |0‚ü© ‚Ü¶ cos(Œ∏/2)|0‚ü© + sin(Œ∏/2)|1‚ü© = sqrt(2^n/N) |0‚ü© + sqrt(r/N)|1‚ü©

    // state : 
    // (sqrt(2^n)/sqrt(N))|0‚ü©‚äó(|0‚ü©‚äó ‚ãØ ‚äó|0‚ü©) + (sqrt(r)/sqrt(N))|1‚ü©‚äó(|0‚ü©‚äó ‚ãØ ‚äó|0‚ü©)

    // conditionally on first qubit either prepare 
    // the uniform distribution on n qubits or 
    // (recursively) the remainder |0‚ü© + ... + |r-1‚ü©
    if head {
        tail := superposition(r, tail); // (|0‚ü© + ... + |r-1‚ü©)/sqrt(r)
    }
    else {
        for i in [0..n) { tail[i] := H(tail[i]); } // ‚àë·µ•|v‚ü©/sqrt(2^n)
    }

    // tail = (x‚ÇÅ, ..., x‚Çô, x‚Çô‚Çä‚ÇÅ, ..., x‚Çñ) and 
    // head (= x‚ÇÄ) is the MSB of (x‚ÇÅ, ..., x‚Çô, x‚ÇÄ)
    for i in [0..n div 2) { (tail[i], tail[n-1-i]) := (tail[n-1-i], tail[i]); } 
    // tail = (x‚Çô, ..., x‚ÇÅ, x‚Çô‚Çä‚ÇÅ, ..., x‚Çñ)
    
    qs:=(head,)~tail;                                                           
    // qs = (x‚ÇÄ, x‚Çô, ..., x‚ÇÅ, x‚Çô‚Çä‚ÇÅ, ..., x‚Çñ)
    
    for i in [0..(n+1) div 2) { (qs[i], qs[n-i]) := (qs[n-i], qs[i]); }         
    // qs = (x‚ÇÅ, ..., x‚Çô, x‚ÇÄ, x‚Çô‚Çä‚ÇÅ, ..., x‚Çñ)

    // state :   
    // (sqrt(2^n)/sqrt(N))|0‚ü©‚äó(‚àë·µ•|v‚ü©/sqrt(2^n)) + 
    // (sqrt(r)/sqrt(N))|1‚ü©‚äó((|0‚ü© + ... + |r-1‚ü©)/sqrt(r)
    // = (1/sqrt(N))(|0‚ü© + ... + |N-1‚ü©)

    return qs;
}

/* TEST */

def test_superposition() { 
    k := 5;
    qs := vector(k, 0:ùîπ);
    qs := superposition(19, qs);
    measure(qs);
}

/* EXAMPLE CALL */

def main() {
    N := 19;
    // generates the normalized superposition |0‚ü© + ... + |18‚ü© on 5 qubits
    qs := superposition(N,  vector(5, 0:ùîπ)) as uint[5];

    // measures 0 <= n < 19 
    n := measure(qs); 
    assert(n < N);
    return(n);
}