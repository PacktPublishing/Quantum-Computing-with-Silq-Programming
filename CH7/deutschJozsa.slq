// Deutsch-Jozsa algorithm 
// - Returns : | 0 if f is balanced (#{x, f(x)=0} = #{x, f(x)=1})
//             | 1 if f is constant (âˆ€x f(x)=0 or âˆ€x f(x)=1)


def deutsch_jozsa[n:!â„•](f: const int[n] !â†’ lifted ğ”¹):!ğ”¹{
  cand := 0:int[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // âˆ‘áµ¥|vâŸ©

  if f(cand) {
	  phase(Ï€);
  }

  // state ignoring normalization:
  // âˆ‘áµ¥(-1)^f(v)|vâŸ©

  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  //   âˆ‘áµ¥(-1)^f(v) âˆ‘áµ¤ (-1)^(uÂ·v)|uâŸ©  

  result := measure(cand);
  // probability to measure 0 is:
  // - 1 if f constant (constructive interference) 
  // - 0 if f balanced (destructive interference)
  return result==0;
}

/* TEST */

def test_balanced() {
  def balanced(x:int[2])lifted:ğ”¹{
    if (x[0]==1) { 
      return 1:ğ”¹;
    }
    else {
      return 0:ğ”¹;
    }
  } // implements a balanced function (outputs half 0 and half 1)
  x := deutsch_jozsa(balanced);
  assert(x == 0); 
  return x;
}

def test_constant() {
  def constant(x:int[2])lifted:ğ”¹{
    return 1:ğ”¹;
  } // implements a constant function (outputs only 1)
  x := deutsch_jozsa(constant);
  assert(x == 1);
  return x;
}

def main() {
  print(test_balanced()); // DJ on balanced function should output 0
  print(test_constant()); // DJ on constant function should output 1
  return;
}
