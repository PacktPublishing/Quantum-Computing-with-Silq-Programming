// Grover's algorithm for a single solution
// - Returns the only x for which f(x) = 1
//
// - More detailed description: https://www.scottaaronson.com/qclec/22.pdf

import helpers.groverDiffusion;

def grover[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{ 
	nIterations:= round(Ï€ / 4 * sqrt(2^n));
	cand:=0:uint[n];
    for k in [0..n) {cand[k] := H(cand[k]);} 
	
	for k in [0..nIterations){
		if f(cand){
			phase(Ï€);
		}		
		// state ignoring normalization:   
    	// âˆ‘(vâ‰ w)|vâŸ© - |w*âŸ©
		cand:=groverDiffusion(cand);  
    	// âˆ‘(vâ‰ w)Î³â‚‹|vâŸ© + Î³â‚Š|w*âŸ©
	}
	return measure(cand) as !â„•;
}

/* EXAMPLE CALL */

def main() {
	f := Î»(x:uint[5])lifted:ğ”¹{return x==3;}; // creates an oracle which outputs one only when x=3
	x := grover(f); 
	assert(x==3); // verifies that grover finds the right solution

	return x;
}

/* TEST */ 

// This function defines a test for Grover
def test_grover() {
	def f(x:uint[3])lifted:ğ”¹{
    	return x==7;
	} // creates an oracle which outputs one only when x=3
	x := grover(f);
	// verifies that grover finds the right solution
	assert(x==7);

	return x;
}


